# 哔哩哔哩时间线项目后端编码规程文档

## 一、文档概述

本文档基于对现有项目代码库的全面扫描分析，系统性地提取了团队在实际开发过程中遵循的后端编码规范、风格约定及最佳实践。文档涵盖代码风格指南、测试规范、版本控制规范、构建与部署规范、架构设计原则、错误处理标准及质量检查标准等内容，旨在为团队成员提供统一、可操作的编码指导，确保代码库的一致性和可维护性。

本项目后端使用 Python 3 实现自动化数据爬取功能，主要包括视频信息爬取、元数据处理和数据存储等功能。团队在开发过程中形成了具有特色的代码组织方式、完善的异常处理机制以及清晰的函数命名规范，这些实践已在实际项目中得到验证。

---

## 二、代码风格指南

### 2.1 文件编码与格式规范

项目统一采用 UTF-8 编码格式，确保跨平台兼容性和中文字符的正确显示。所有 Python 源代码文件必须以 UTF-8 编码保存，不得使用其他编码格式，以避免中文注释和数据出现乱码问题。文件换行符统一使用 LF（Line Feed）格式，在 Windows 环境下开发时需特别注意编辑器的换行符配置，建议将编辑器设置为自动转换或使用 .editorconfig 文件进行统一管理。

文件末尾必须保留一个空行，这是许多静态检查工具和版本控制系统推荐的最佳实践。文件末尾的空行有助于避免某些版本控制工具报告的差异问题，同时也能让文件在终端查看时显示更加规范。每个文件应该只包含一个主要功能或类，避免在单个文件中实现过多不相关的功能。

### 2.2 缩进与空格规范

Python 后端代码严格遵循 PEP 8 风格指南，使用 4 空格缩进，不使用 Tab 字符。所有 `.py` 文件必须添加 shebang 行（`#!/usr/bin/env python3`），并在文件开头添加模块文档字符串，说明模块的功能和用途。

```python
#!/usr/bin/env python3
"""
自动化爬取脚本
用于定时从B站根据关键词搜索视频，爬取视频信息，存储到JSON文件
"""

import requests
import json
import time
import os
import re
from bs4 import BeautifulSoup
from pathlib import Path
from datetime import datetime
```

导入语句应分组放置，标准库导入放在最前面，其次是第三方库导入，最后是本地应用导入。每组导入之间用空行分隔，避免将所有导入混合在一起。

### 2.3 命名规范

命名规范是保证代码可读性和可维护性的基础。项目对不同类型的标识符采用不同的命名约定，以确保代码的一致性和表达力。

- **类名**：采用 PascalCase 命名法，如 `BiliBiliAutoCrawler`、`VideoMetadataParser`。
- **函数名和变量名**：采用 snake_case 命名法，如 `search_videos`、`crawl_video_metadata`、`pending_file`。
- **私有方法和属性**：使用单下划线前缀，如 `_extract_bv_codes`、`_init_storage_files`。
- **模块级常量**：采用全大写加下划线命名法，如 `MAX_PAGES`、`REQUEST_DELAY`、`DEFAULT_TIMEOUT`。
- **文件名**：使用 snake_case 命名法，如 `auto_crawler.py`、`crawl_metadata.py`、`download_thumbs.py`。

```python
class BiliBiliAutoCrawler:
    """B站视频爬虫类"""
    
    # 类常量
    MAX_PAGES = 5
    REQUEST_DELAY = 2
    DEFAULT_TIMEOUT = 15
    
    def __init__(self):
        """初始化爬虫实例"""
        self.session = requests.Session()
        self.data_dir = Path('data')
    
    def _extract_bv_codes(self, html):
        """从HTML中提取BV号"""
        bv_pattern = r'BV([0-9A-Za-z]+)'
        bv_codes = re.findall(bv_pattern, html)
        return list(set(bv_codes))[:20]
    
    def crawl_video_metadata(self, bv_code):
        """爬取视频元数据"""
        video_url = f"https://www.bilibili.com/video/BV{bv_code}"
        # 实现逻辑...
```

### 2.4 注释规范

项目要求所有函数、类和复杂逻辑必须添加中文注释，注释语言应与项目整体语言保持一致。注释使用中文编写，包括函数说明、参数说明、返回值说明和代码逻辑说明。注释格式采用 Google 风格的文档字符串，对于导出的函数和类尤为重要。

```python
def search_videos(self, keyword, page=1, order='totalrank'):
    """搜索视频
    
    Args:
        keyword (str): 搜索关键词
        page (int): 页码，默认值为1
        order (str): 排序方式，可选值：totalrank(综合), click(播放量), pubdate(最新), stow(收藏)
    
    Returns:
        list: BV号列表
    """
    print(f"搜索视频: {keyword}, 页码: {page}, 排序: {order}")
    # 实现逻辑...
```

对于复杂的算法和数据结构，应添加清晰的注释说明其原理和思路。行内注释应简洁明了，避免显而易见的注释，注释应聚焦于解释「为什么」而非「是什么」。代码修改时，应同步更新相关的注释内容，确保注释与代码的一致性。

### 2.5 代码组织规范

代码组织应遵循模块化原则，将相关功能组织在同一个模块中。每个文件应该只包含一个主要功能或类，避免在单个文件中实现过多不相关的功能。函数应保持短小精悍，每个函数只负责一个明确的功能，函数长度不宜超过 50 行。

```python
# 良好的代码组织示例
class BiliBiliAutoCrawler:
    """B站视频爬虫类"""
    
    def __init__(self):
        """初始化爬虫实例"""
        # 初始化代码...
    
    def search_videos(self, keyword, page=1, order='totalrank'):
        """搜索视频"""
        # 实现逻辑...
    
    def crawl_video_metadata(self, bv_code):
        """爬取视频元数据"""
        # 实现逻辑...
    
    def save_to_pending(self, metadata):
        """保存到待审核列表"""
        # 实现逻辑...
    
    def generate_timeline(self):
        """生成时间线数据"""
        # 实现逻辑...
```

---

## 三、测试规范

### 3.1 单元测试规范

项目使用 pytest 或 unittest 框架编写单元测试，测试文件应与被测试模块放在同一目录下，命名为 `test_*.py` 或 `*_test.py`。测试用例应覆盖主要功能和边界情况，包括正常流程测试、异常处理测试和边界条件测试。

测试代码应保持简洁，使用有意义的测试描述，并遵循 AAA 模式（Arrange-Act-Assert）。每个测试用例应只测试一个功能点，避免在单个测试用例中测试多个功能。

```python
# 测试用例示例
import unittest
from auto_crawler import BiliBiliAutoCrawler

class TestBiliBiliAutoCrawler(unittest.TestCase):
    """B站爬虫测试类"""
    
    def setUp(self):
        """测试初始化"""
        self.crawler = BiliBiliAutoCrawler()
    
    def test_search_videos(self):
        """测试视频搜索功能"""
        # Arrange
        keyword = "原神"
        
        # Act
        result = self.crawler.search_videos(keyword, page=1)
        
        # Assert
        self.assertIsInstance(result, list)
        self.assertGreaterEqual(len(result), 0)
    
    def test_extract_bv_codes(self):
        """测试BV号提取功能"""
        # Arrange
        html = '<a href="/video/BV1xx411c7mD">测试视频</a>'
        
        # Act
        result = self.crawler._extract_bv_codes(html)
        
        # Assert
        self.assertIsInstance(result, list)
        self.assertIn("1xx411c7mD", result)
```

### 3.2 测试组织规范

测试文件应与被测试的模块或类放在相近的位置，便于维护和查找。测试用例应按照功能模块组织在测试类中，每个测试类描述一个测试套件的主题。测试用例描述应清晰表达测试的目的，使用中文描述以便团队成员理解。

每个测试用例应有明确的预期，使用断言语句明确断言期望的结果。测试应避免依赖外部资源和网络请求，对于需要外部资源的测试，应使用模拟（mock）对象进行替代。测试完成后应进行必要的清理工作，确保测试环境的干净和测试的独立性。

### 3.3 集成测试规范

除了单元测试外，项目还应编写集成测试，验证多个模块或组件之间的协作。集成测试应模拟真实的用户交互场景，验证完整的业务流程是否正常。集成测试文件命名为 `integration_test.py` 或 `test_integration.py`，放在测试目录的根目录下。

---

## 四、版本控制规范

### 4.1 Git 提交规范

项目使用 Git 进行版本控制，提交信息应遵循统一的格式规范。提交信息应清晰地描述本次提交的内容和目的，包含类型标识、简要描述和详细说明（可选）。推荐使用 Conventional Commits 格式，但不强求完全遵循。

```bash
# 提交类型示例
feat: 添加视频元数据爬取功能
fix: 修复视频信息解析错误
docs: 更新README文档
style: 代码格式调整
refactor: 重构爬虫逻辑
test: 添加视频搜索测试用例
chore: 更新依赖版本
```

每次提交应保持原子性，即一次提交只包含一个完整的改动。避免在一次提交中混入多个不相关的修改，也不要将一个完整的修改拆分成多次不完整的提交。提交信息应使用中文或英文，团队应统一使用同一种语言。

### 4.2 分支管理规范

项目应采用清晰的分支管理策略，推荐使用 Git Flow 或类似的工作流程。主要分支包括 main 或 master（主分支，始终保持稳定可发布状态）、develop（开发分支，集成最新的开发成果）和 feature/*（功能分支，开发新功能时创建）、hotfix/*（热修复分支，紧急修复生产问题时创建）。

```bash
# 分支命名规范
feature/video-crawler    # 新功能开发
feature/metadata-parser  # 新功能开发
hotfix/critical-bug      # 紧急修复
release/v1.0.0           # 发布准备
```

功能开发应在独立的分支上进行，完成后通过 Pull Request 合并到开发分支或主分支。分支名称应清晰表达其用途，使用小写字母和连字符命名。长期存在的分支应定期与主分支同步，避免产生大量的合并冲突。

---

## 五、构建与部署规范

### 5.1 依赖管理规范

项目的依赖管理通过 requirements.txt 文件进行，所有第三方依赖应明确指定版本号，避免因依赖版本变化导致的兼容性问题。依赖版本应使用语义化版本控制（SemVer），确保依赖的稳定性和安全性。

```bash
# requirements.txt 示例
requests>=2.28.0
beautifulsoup4>=4.11.0
python-dotenv>=0.20.0
```

应定期检查依赖的安全漏洞，使用 `pip audit` 命令进行安全检查。添加新依赖时应评估其必要性、维护状态和体积影响，避免引入不必要的依赖。

### 5.2 环境变量规范

项目使用 .env 文件管理环境变量，开发环境配置在 .env.development 文件中，生产环境配置在 .env.production 文件中。环境变量应以项目名称作为前缀，如 `BILIBILI_API_KEY`、`BILIBILI_SEARCH_URL` 等。敏感信息（如 API 密钥）不应提交到版本控制系统中，应在 .env.example 文件中提供模板并在团队内部安全地分享实际的配置值。

```bash
# .env.example 示例
BILIBILI_SEARCH_URL=https://search.bilibili.com/video
BILIBILI_API_KEY=your_api_key_here
REQUEST_DELAY=2
MAX_PAGES=5
```

### 5.3 构建与部署流程

项目的构建与部署流程应自动化，推荐使用 CI/CD 工具（如 GitHub Actions、GitLab CI）进行自动化构建和部署。构建过程应包括依赖安装、代码检查、测试执行和打包等步骤，确保构建产物的质量和可靠性。

部署过程应遵循环境隔离原则，开发、测试和生产环境应相互隔离，避免环境间的相互影响。部署前应进行充分的测试，确保部署后的系统能够正常运行。

---

## 六、架构设计原则

### 6.1 目录结构规范

项目采用清晰的目录结构组织代码，后端源码在 backend 目录下。主要目录包括：

```
backend/
├── src/                 # 主源码目录
│   ├── crawler/         # 爬虫核心模块
│   │   ├── __init__.py
│   │   └── auto_crawler.py       # 自动化爬虫实现
│   ├── downloader/      # 下载模块
│   │   ├── __init__.py
│   │   └── download_thumbs.py    # 缩略图下载功能
│   ├── commands/        # 命令行工具
│   │   ├── __init__.py
│   │   └── approve_videos.py     # 视频审核工具
│   └── utils/           # 工具函数
│       ├── __init__.py
│       └── config.py    # 配置文件
├── data/                # 数据存储目录
│   ├── raw/             # 原始爬取数据
│   │   ├── pending.json     # 待审核视频列表
│   │   ├── approved.json    # 已通过审核视频列表
│   │   └── rejected.json    # 已拒绝视频列表
│   ├── processed/       # 处理后的数据
│   │   └── videos.json      # 前端时间线数据
│   ├── sources/         # BV号来源文件
│   │   ├── lvjiang-bv.txt   # 驴酱UP主的BV号列表
│   │   └── tiantong-bv.txt  # 甜筒UP主的BV号列表
│   └── README.md        # 数据目录说明
├── tests/               # 测试目录
│   ├── __init__.py
│   └── test_*.py        # 单元测试文件
├── main.py              # 主入口脚本
├── requirements.txt     # 依赖文件
└── README.md            # 项目说明文档
```

每个功能模块的代码组织在独立的文件中，使用 `src/` 目录作为源代码根目录，按功能模块（crawler、downloader、commands、utils）进行划分。数据文件放在 `data/` 目录下，按照数据类型（raw、processed、sources）组织。这种结构使得代码易于定位和维护。

### 6.2 类与函数设计原则

类的设计应遵循单一职责原则，每个类只负责一个明确的功能或职责。类的属性和方法应保持封装性，使用访问控制修饰符（如单下划线前缀）保护内部实现细节。函数的设计应遵循高内聚、低耦合原则，函数之间的依赖关系应尽可能简单和明确。

```python
class BiliBiliAutoCrawler:
    """B站视频爬虫类，负责视频搜索和爬取"""
    
    def __init__(self):
        """初始化爬虫实例"""
        self._init_session()
        self._init_storage()
    
    def _init_session(self):
        """初始化请求会话"""
        # 实现逻辑...
    
    def _init_storage(self):
        """初始化存储目录"""
        # 实现逻辑...
    
    def search_videos(self, keyword, page=1, order='totalrank'):
        """搜索视频"""
        # 实现逻辑...
    
    def crawl_video_metadata(self, bv_code):
        """爬取视频元数据"""
        # 实现逻辑...
```

### 6.3 数据管理原则

数据管理应遵循分层原则，将数据访问逻辑与业务逻辑分离。数据存储格式应清晰、结构化，便于后续的数据分析和处理。推荐使用 JSON 或 CSV 格式存储数据，便于跨平台使用和后续处理。

```python
def save_to_pending(self, metadata):
    """保存到待审核列表
    
    Args:
        metadata (dict): 视频元数据
    
    Returns:
        bool: 保存成功返回True，否则返回False
    """
    # 加载现有数据
    with open(self.pending_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # 检查是否已存在
    existing_bvs = [video['bv'] for video in data['videos']]
    if metadata['bv'] in existing_bvs:
        print(f"视频 BV{metadata['bv']} 已存在，跳过")
        return False
    
    # 添加新视频
    data['videos'].append(metadata)
    
    # 保存数据
    with open(self.pending_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    
    print(f"视频 BV{metadata['bv']} 已保存到待审核列表")
    return True
```

---

## 七、错误处理规范

### 7.1 异常捕获规范

项目应在适当的层级进行异常捕获和处理，避免未捕获的错误导致应用崩溃。异步操作和网络请求应使用 try-catch 块捕获可能的错误，并进行合理的错误处理。错误信息应清晰表达问题的原因，便于调试和问题定位。

```python
def crawl_video_metadata(self, bv_code):
    """爬取视频元数据"""
    print(f"爬取视频元数据: BV{bv_code}")
    
    video_url = f"https://www.bilibili.com/video/BV{bv_code}"
    
    try:
        response = self.session.get(video_url, timeout=15)
        response.raise_for_status()
        
        # 解析视频页面
        metadata = self._parse_video_page(response.text, bv_code)
        return metadata
        
    except requests.exceptions.RequestException as e:
        print(f"网络请求错误: {e}")
        return None
    except Exception as e:
        print(f"爬取错误: {e}")
        return None
```

### 7.2 错误日志规范

项目应使用适当的日志记录机制，记录应用运行过程中的重要事件和错误信息。日志应包括时间戳、日志级别、模块名称和具体的日志信息，便于后续的日志分析和问题定位。推荐使用 Python 标准库中的 logging 模块进行日志记录。

```python
import logging

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('crawler.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

def crawl_video_metadata(self, bv_code):
    """爬取视频元数据"""
    logger.info(f"爬取视频元数据: BV{bv_code}")
    
    try:
        # 实现逻辑...
        logger.info(f"成功爬取视频元数据: BV{bv_code}")
        return metadata
    except Exception as e:
        logger.error(f"爬取错误: {e}")
        return None
```

### 7.3 边界情况处理

函数和方法应处理各种边界情况，包括空值、无效参数、异常输入等。对于可能出现的边界情况，应进行适当的检查和处理，避免程序崩溃或产生不正确的结果。

```python
def generate_timeline(self):
    """生成时间线数据"""
    logger.info("生成时间线数据...")
    
    try:
        # 加载已通过的视频数据
        with open(self.approved_file, 'r', encoding='utf-8') as f:
            approved_data = json.load(f)
        
        videos = approved_data.get('videos', [])
        
        # 边界情况处理
        if not videos:
            logger.warning("没有已通过的视频数据")
            return 0
        
        # 按照发布日期排序（降序）
        videos.sort(key=lambda x: x.get('publish_date', ''), reverse=True)
        
        # 生成timeline数据
        timeline_data = []
        for video in videos:
            timeline_item = {
                "id": len(timeline_data) + 1,
                "date": video.get('publish_date'),
                "title": video.get('title'),
                "content": video.get('description', ''),
                "video": {
                    "bv": video.get('bv'),
                    "url": video.get('url')
                },
                "thumbnail": video.get('thumbnail'),
                "views": video.get('views'),
                "danmaku": video.get('danmaku'),
                "up主": video.get('up主')
            }
            timeline_data.append(timeline_item)
        
        # 保存到前端目录
        timeline_path = Path('../frontend/public/timeline.json')
        timeline_path.parent.mkdir(exist_ok=True)
        
        with open(timeline_path, 'w', encoding='utf-8') as f:
            json.dump(timeline_data, f, ensure_ascii=False, indent=2)
        
        logger.info(f"生成了时间线数据，保存到: {timeline_path}")
        logger.info(f"时间线包含 {len(timeline_data)} 个视频")
        
        return len(timeline_data)
    
    except FileNotFoundError as e:
        logger.error(f"文件不存在: {e}")
        return 0
    except json.JSONDecodeError as e:
        logger.error(f"JSON解析错误: {e}")
        return 0
    except Exception as e:
        logger.error(f"生成时间线数据错误: {e}")
        return 0
```

---

## 八、文档与注释规范

### 8.1 代码内注释规范

代码中的注释应清晰、有价值，避免显而易见的注释。注释应解释「为什么」而非「是什么」，即解释代码的设计决策和业务逻辑，而非重复代码本身。复杂的算法和数据结构应添加注释说明其原理和思路。

```python
# 设备检测逻辑 - 只支持平板和桌面设备
const detectDevice = (): DeviceType => {
  const width = window.innerWidth;
  if (width < BREAKPOINTS.tablet) return "tablet";
  return "desktop";
};
```

### 8.2 外部文档规范

项目应维护必要的外部文档，包括 README 文件（项目概述、安装步骤、使用说明）、API 文档（接口说明、数据格式）、开发文档（架构设计、技术选型）。文档应与代码保持同步更新，避免文档与实际实现脱节。

README.md 文件应包含项目概述、功能特性、安装步骤、使用说明和贡献指南等内容，便于新加入的团队成员快速了解和使用项目。

---

## 九、总结与执行

本文档系统性地梳理了团队在哔哩哔哩时间线项目中形成的后端编码规范和最佳实践，涵盖代码风格、测试规范、版本控制、构建部署、架构设计、错误处理和文档规范等方面。

团队成员应熟悉并遵循本文档的规定，在日常开发中保持代码风格的一致性。新加入团队的成员应在入职培训中学习本文档的内容，并在实际开发中逐步掌握各项规范。规范不是一成不变的，团队可以根据实际情况进行调整和优化，但任何修改都应经过讨论并更新本文档。

通过遵循统一的编码规范，团队可以提高代码的可读性、可维护性和协作效率，减少代码审查的时间和成本，提升整体开发体验和产品质量。

---

**文档版本**：1.0  
**创建日期**：2024年  
**适用项目**：bilibili-timeline  
**最后更新**：2024年