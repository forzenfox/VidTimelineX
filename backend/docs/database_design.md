# 数据存储设计文档

## 1. 设计目标

- **数据隔离**：实现甜筒和驴酱数据的完全隔离
- **结构清晰**：数据存储结构清晰易懂
- **可扩展性**：支持未来可能的其他数据类型扩展
- **性能优化**：确保数据操作的高效性
- **数据安全**：保证数据的安全性和完整性

## 2. 数据存储结构

### 2.1 目录结构

```
data/
├── common/              # 公共数据
│   └── bv-lists/        # BV号文件目录
│       ├── lvjiang-bv.txt    # 驴酱BV号文件
│       └── tiantong-bv.txt   # 甜筒BV号文件
├── lvjiang/             # 驴酱数据
│   ├── pending.json     # 待审核视频
│   ├── approved.json    # 已通过视频
│   ├── rejected.json    # 已拒绝视频
│   ├── videos.json      # 时间线数据
│   └── thumbs/          # 封面图片
├── tiantong/            # 甜筒数据
│   ├── pending.json     # 待审核视频
│   ├── approved.json    # 已通过视频
│   ├── rejected.json    # 已拒绝视频
│   ├── videos.json      # 时间线数据
│   └── thumbs/          # 封面图片
└── [其他类型]/           # 未来扩展
```

### 2.2 目录说明

| 目录 | 用途 | 权限 |
|------|------|------|
| `data/common/` | 存储公共数据 | 读写 |
| `data/common/bv-lists/` | 存储BV号文件 | 读写 |
| `data/[type]/` | 存储特定类型的数据 | 读写 |
| `data/[type]/thumbs/` | 存储特定类型的封面图片 | 读写 |

## 3. 数据文件格式

### 3.1 视频数据文件

#### 3.1.1 待审核文件 (pending.json)

```json
{
  "videos": [
    {
      "bv": "视频BV号",
      "url": "视频URL",
      "title": "视频标题",
      "description": "视频描述",
      "publish_date": "发布日期",
      "views": 播放量,
      "danmaku": 弹幕数,
      "up主": "UP主名称",
      "cover_url": "封面图片URL",
      "thumbnail": "封面图片路径",
      "duration": "视频时长",
      "crawled_at": "爬取时间",
      "review_status": "pending",
      "review_note": ""
    }
  ]
}
```

#### 3.1.2 已通过文件 (approved.json)

```json
{
  "videos": [
    {
      "bv": "视频BV号",
      "url": "视频URL",
      "title": "视频标题",
      "description": "视频描述",
      "publish_date": "发布日期",
      "views": 播放量,
      "danmaku": 弹幕数,
      "up主": "UP主名称",
      "cover_url": "封面图片URL",
      "thumbnail": "封面图片路径",
      "duration": "视频时长",
      "crawled_at": "爬取时间",
      "review_status": "approved",
      "review_note": "审核备注"
    }
  ]
}
```

#### 3.1.3 已拒绝文件 (rejected.json)

```json
{
  "videos": [
    {
      "bv": "视频BV号",
      "url": "视频URL",
      "title": "视频标题",
      "description": "视频描述",
      "publish_date": "发布日期",
      "views": 播放量,
      "danmaku": 弹幕数,
      "up主": "UP主名称",
      "cover_url": "封面图片URL",
      "thumbnail": "封面图片路径",
      "duration": "视频时长",
      "crawled_at": "爬取时间",
      "review_status": "rejected",
      "review_note": "拒绝原因"
    }
  ]
}
```

### 3.2 时间线数据文件

#### 3.2.1 时间线文件 (videos.json)

```json
[
  {
    "id": "视频ID",
    "title": "视频标题",
    "date": "发布日期",
    "videoUrl": "视频URL",
    "cover": "封面图片文件名",
    "cover_url": "封面图片URL",
    "tags": [],
    "duration": "视频时长"
  }
]
```

### 3.3 BV号文件

#### 3.3.1 格式

```
# 注释行
BV1234567890
1234567890  # 不带BV前缀的BV号
```

## 4. 数据隔离实现

### 4.1 存储层隔离

#### 4.1.1 目录隔离

- **独立目录**：为每种数据类型创建独立的目录
- **统一结构**：所有数据类型的目录结构保持一致
- **路径管理**：通过路径管理模块动态生成路径

#### 4.1.2 文件隔离

- **独立文件**：每种数据类型拥有独立的JSON文件
- **文件结构**：所有数据类型的文件结构保持一致
- **数据分离**：不同数据类型的数据存储在不同的文件中

#### 4.1.3 封面隔离

- **独立目录**：每种数据类型拥有独立的封面存储目录
- **文件名**：封面文件以BV号命名，确保唯一性
- **路径管理**：通过路径管理模块获取对应数据类型的封面目录

### 4.2 配置层隔离

#### 4.2.1 配置管理

- **主配置**：存储通用配置
- **数据类型配置**：每种数据类型的特定配置
- **配置访问**：通过配置管理模块获取配置

#### 4.2.2 路径管理

- **路径生成**：根据数据类型动态生成路径
- **路径验证**：验证路径的有效性
- **目录创建**：自动创建不存在的目录

### 4.3 代码层隔离

#### 4.3.1 数据类型枚举

```python
# src/utils/config.py

DATA_TYPES = {
    'LVJIANG': 'lvjiang',    # 驴酱
    'TIANTONG': 'tiantong'   # 甜筒
}
```

#### 4.3.2 存储逻辑

```python
# src/crawler/auto_crawler.py

class BiliBiliAutoCrawler:
    def __init__(self, data_type='lvjiang'):
        self.data_type = data_type
        self.config = get_data_type_config(data_type)
        # 其他初始化
    
    def save_to_pending(self, metadata):
        # 保存到对应数据类型的pending.json
        pass
    
    def save_to_approved(self, metadata):
        # 保存到对应数据类型的approved.json
        pass
```

#### 4.3.3 数据访问

```python
# src/utils/path_manager.py

def get_data_paths(data_type):
    """获取数据存储路径"""
    config = get_data_type_config(data_type)
    return config

def get_bv_file_path(data_type):
    """获取BV号文件路径"""
    file_names = {
        'lvjiang': 'lvjiang-bv.txt',
        'tiantong': 'tiantong-bv.txt'
    }
    return Config.BV_LISTS_DIR / file_names.get(data_type, f'{data_type}-bv.txt')
```

## 5. 数据迁移策略

### 5.1 现有数据迁移

#### 5.1.1 迁移步骤

1. **备份现有数据**：
   - 备份整个data目录
   - 确保备份的完整性

2. **创建新目录结构**：
   - 创建common/bv-lists/目录
   - 创建lvjiang/和tiantong/目录
   - 创建各目录下的thumbs/子目录

3. **迁移BV号文件**：
   - 将lvjiang-bv.txt迁移到common/bv-lists/
   - 将tiantong-bv.txt迁移到common/bv-lists/

4. **迁移视频数据**：
   - 分析现有数据，将其分类到对应的数据类型
   - 将数据写入新的目录结构

5. **迁移封面图片**：
   - 分析现有封面，将其分类到对应的数据类型
   - 将封面图片复制到对应的数据类型的thumbs/目录

#### 5.1.2 迁移脚本

```python
# scripts/migrate_data.py

import os
import shutil
import json
from pathlib import Path

# 迁移逻辑
```

### 5.2 数据验证

#### 5.2.1 验证步骤

1. **目录结构验证**：确保所有目录都已创建
2. **文件验证**：确保所有文件都已迁移
3. **数据验证**：确保数据的完整性和一致性
4. **功能验证**：确保系统功能正常

#### 5.2.2 回滚机制

- **备份保留**：保留原始数据备份
- **回滚脚本**：准备数据回滚脚本
- **回滚测试**：测试回滚功能

## 6. 数据访问优化

### 6.1 读取优化

- **批量读取**：批量读取数据，减少I/O操作
- **缓存机制**：缓存频繁访问的数据
- **异步读取**：使用异步I/O读取大文件

### 6.2 写入优化

- **批量写入**：批量写入数据，减少I/O操作
- **增量更新**：只更新变化的数据
- **异步写入**：使用异步I/O写入大文件

### 6.3 存储优化

- **文件压缩**：对于大文件，考虑使用压缩存储
- **索引机制**：为频繁查询的字段创建索引
- **数据分片**：对于超大数据集，考虑数据分片

## 7. 数据安全

### 7.1 数据完整性

- **数据验证**：验证数据的格式和完整性
- **错误处理**：完善的错误处理机制
- **事务性操作**：确保数据操作的原子性

### 7.2 数据安全

- **路径验证**：防止路径遍历攻击
- **输入验证**：验证用户输入
- **错误信息**：安全处理错误信息

### 7.3 备份策略

- **定期备份**：定期备份数据
- **备份存储**：将备份存储在安全的位置
- **备份验证**：验证备份的完整性

## 8. 扩展性设计

### 8.1 数据类型扩展

- **配置扩展**：在DATA_TYPES中添加新的数据类型
- **目录创建**：自动为新数据类型创建目录结构
- **路径管理**：支持新数据类型的路径管理

### 8.2 存储方式扩展

- **存储抽象**：抽象存储接口
- **存储实现**：支持多种存储实现
- **配置切换**：通过配置切换存储方式

### 8.3 数据格式扩展

- **版本控制**：支持数据格式的版本控制
- **向后兼容**：确保新格式与旧格式兼容
- **迁移工具**：提供数据格式迁移工具

## 9. 性能考虑

### 9.1 内存管理

- **数据处理**：分批处理大量数据
- **对象复用**：复用对象，减少内存分配
- **垃圾回收**：及时释放不再使用的内存

### 9.2 I/O性能

- **文件操作**：批量文件操作
- **缓存策略**：缓存频繁访问的文件数据
- **异步I/O**：使用异步I/O处理文件操作

### 9.3 并发处理

- **多线程**：使用多线程处理数据操作
- **线程安全**：确保数据操作的线程安全
- **锁机制**：合理使用锁机制

## 10. 结论

本数据存储设计文档详细描述了VidTimelineX系统的数据存储结构和隔离方案。通过实现甜筒和驴酱数据的完全隔离，系统将具有更好的可管理性和可维护性。

设计考虑了数据的安全性、完整性和性能，确保系统能够高效地处理和存储数据。同时，设计具有良好的扩展性，支持未来添加新的数据类型和功能。

数据迁移策略确保了现有数据的平滑迁移，减少了系统升级的风险。数据访问优化和性能考虑确保了系统的响应速度和稳定性。

通过本设计，系统将能够满足用户的需求，提供更加可靠、高效的数据管理功能。